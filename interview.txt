Вопрос: Какие изменяемые и не изменяемые типы данных в питон3
Ответ:В Python 3 основные неизменяемые типы данных включают:
        Целые числа (int) – это базовый тип для целых чисел.
        Числа с плавающей запятой (float) – используются для представления действительных чисел.
        Комплексные числа (complex) – используются для представления комплексных чисел.
        Строки (str) – представляют текстовые данные и объявляются в одинарных, двойных или тройных кавычках.
        Кортежи (tuple) – похожи на списки, но не могут быть изменены после создания.
        Логические значения (bool) – это True и False, используются для оценки условий.
        Диапазоны (range) – представляют неизменяемую последовательность чисел и часто используются в циклах for.

        Основные изменяемые типы данных в Python 3 включают:
        Списки (list) – упорядоченная коллекция, которая может содержать элементы различных типов, и их можно изменить.
        Словари (dict) – неупорядоченная коллекция пар ключ-значение. Ключи должны быть неизменяемыми, но значения могут быть любых типов и изменяемыми.
        Множества (set) – неупорядоченная коллекция уникальных, изменяемых элементов.
        Замороженные множества (frozenset) – тоже является множеством, но неизменяемым типом.






Вопрос: Что такое декораторы в Python и как они работают?
Ответ: Декораторы в Python - это специальные функции, которые могут модифицировать поведение других функций или методов, 
        не изменяя их кода напрямую. Они предоставляют простой синтаксис для расширения и изменения логики функций, 
        добавляя функциональность до или после основной функции. Декораторы оборачивают функцию, добавляя свой код выполняться до и/или после обёрнутой функции.


Вопрос: В каких случаях лучше использовать генераторы вместо списков в Python?
Ответ: Генераторы следует использовать когда нам нужно обработать большое количество элементов, 
       которые не умещаются в память, или когда нам не нужны все элементы сразу. 
       Генераторы создают элементы последовательности по требованию ("лениво"), что помогает сэкономить ресурсы, 
       так как они не требуют предварительного создания и хранения всех элементов последовательности в памяти.

Вопрос: Как Django следит за изменениями в моделях и применяет их к базе данных?
Ответ: Django использует систему миграций. 
       Для отслеживания изменений в моделях используется команда makemigrations, 
       которая автоматически создаёт файлы миграции, 
       описывающие эти изменения. 
       Затем команда migrate применяет эти миграции к базе данных, 
       выполняя необходимые SQL-команды для создания или изменения таблиц и полей.

Вопрос: Объясните, как работает шаблон проектирования MTV (Model-Template-View) в Django.
Ответ: MTV — это вариация шаблона MVC (Model-View-Controller), адаптированная для Django. В этом шаблоне:
      Model (Модель) представляет структуру данных приложения и обеспечивает доступ к данным (обычно базе данных).
      Template (Шаблон) отвечает за представление информации и может включать HTML, CSS и Javascript.
      View (Представление) принимает запросы, обращается к модели и представляет данные через шаблон. В контексте Django представления также выполняют роль контроллера, управляя логикой приложения.

Вопрос: Какие механизмы безопасности предоставляет Django "из коробки"?
Ответ: Django предлагает различные средства защиты от распространённых атак, 
        таких как CSRF (Cross-Site Request Forgery), XSS (Cross-Site Scripting), 
        SQL-инъекций и clickjacking-атак. Django предоставляет мидлвари и декораторы для предотвращения этих атак, а также автоматически экранирует вывод в шаблонах для защиты от XSS.

Вопрос: Объясните различие между обычным APIView и ViewSet в DRF.
Ответ: APIView в DRF это более низкоуровневый строительный блок для создания видов, 
       который требует от разработчика явно определять методы обработки HTTP запросов, 
       такие как get, post, и так далее. ViewSet, наоборот, 
       автоматически предоставляет операции CRUD, 
       соединяя вместе логику обычных классов представлений (например, ListAPIView, RetrieveAPIView). 
       ViewSet обычно используется с Router классами, которые автоматически генерируют URL конфигурации для API.

Вопрос: Какие есть способы аутентификации и авторизации в DRF и как они работают?
Ответ:  DRF поддерживает несколько методов аутентификации, таких как Basic Authentication, Token Authentication, OAuth и другие. 
        После аутентификации DRF также поддерживает различные политики и разрешения для авторизации, 
        например IsAuthenticated, IsAdminUser, IsAuthenticatedOrReadOnly. 
        Эти разрешения могут быть прикреплены к представлениям и действиям для управления доступом на уровне представлений и на уровне объектов через permission classes.

Вопрос: Как вы управляете сериализацией вложенных объектов в DRF?
Ответ: В DRF сериализация вложенных объектов может быть выполнена с помощью вложенных сериализаторов (nested serializers). 
       Вам необходимо создать отдельный сериализатор для вложенного объекта и включить его как поле в родительском сериализаторе. 
       Это позволяет контролировать, как вложенные данные представляются в API, и обеспечивает гибкость при обработке вложенных объектов при создании или обновлении.

Если мы сомневаемся и хотим дать тестовое задание

Практическое задание:
Реализуйте консольное приложение на Python3, которое включает в себя следующие функции:
    a. Парсер данных: Написать скрипт, который будет извлекать данные из API (например, публичного API погоды) и анализировать их. Вывести отчёт с основными показателями.
    b. Обработчик ошибок: Добавьте к вашему коду обработку исключений, чтобы скрипт мог корректно обрабатывать возможные ошибки API (нет доступа к сети, API возвращает ошибку, неправильный формат данных и т.д.).
    c. Логирование: Убедитесь, что ваше приложение ведет лог всех выполняемых действий и возникающих ошибок.
    d. Тесты: Напишите юнит-тесты для вашего скрипта, проверяющие ключевые функциональные моменты кода.
    e. Документация: Ваш скрипт должен быть снабжен комментариями и README файлом, описывающим как его установить и использовать.
